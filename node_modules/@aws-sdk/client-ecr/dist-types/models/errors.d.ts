import type { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { ECRServiceException as __BaseException } from "./ECRServiceException";
/**
 * <p>The specified parameter is invalid. Review the available parameters for the API
 *             request.</p>
 * @public
 */
export declare class InvalidParameterException extends __BaseException {
    readonly name: "InvalidParameterException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidParameterException, __BaseException>);
}
/**
 * <p>The specified repository could not be found. Check the spelling of the specified
 *             repository and ensure that you are performing operations on the correct registry.</p>
 * @public
 */
export declare class RepositoryNotFoundException extends __BaseException {
    readonly name: "RepositoryNotFoundException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<RepositoryNotFoundException, __BaseException>);
}
/**
 * <p>These errors are usually caused by a server-side issue.</p>
 * @public
 */
export declare class ServerException extends __BaseException {
    readonly name: "ServerException";
    readonly $fault: "server";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ServerException, __BaseException>);
}
/**
 * <p>The operation did not succeed because it would have exceeded a service limit for your
 *             account. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/service-quotas.html">Amazon ECR service quotas</a> in
 *             the Amazon Elastic Container Registry User Guide.</p>
 * @public
 */
export declare class LimitExceededException extends __BaseException {
    readonly name: "LimitExceededException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<LimitExceededException, __BaseException>);
}
/**
 * <p>The image or images were unable to be pulled using the pull through cache rule. This
 *             is usually caused because of an issue with the Secrets Manager secret containing the credentials
 *             for the upstream registry.</p>
 * @public
 */
export declare class UnableToGetUpstreamImageException extends __BaseException {
    readonly name: "UnableToGetUpstreamImageException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<UnableToGetUpstreamImageException, __BaseException>);
}
/**
 * <p>There was an exception validating this request.</p>
 * @public
 */
export declare class ValidationException extends __BaseException {
    readonly name: "ValidationException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ValidationException, __BaseException>);
}
/**
 * <p>The specified layer upload does not contain any layer parts.</p>
 * @public
 */
export declare class EmptyUploadException extends __BaseException {
    readonly name: "EmptyUploadException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<EmptyUploadException, __BaseException>);
}
/**
 * <p>The layer digest calculation performed by Amazon ECR upon receipt of the image layer does
 *             not match the digest specified.</p>
 * @public
 */
export declare class InvalidLayerException extends __BaseException {
    readonly name: "InvalidLayerException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidLayerException, __BaseException>);
}
/**
 * <p>The operation failed due to a KMS exception.</p>
 * @public
 */
export declare class KmsException extends __BaseException {
    readonly name: "KmsException";
    readonly $fault: "client";
    /**
     * <p>The error code returned by KMS.</p>
     * @public
     */
    kmsError?: string | undefined;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<KmsException, __BaseException>);
}
/**
 * <p>The image layer already exists in the associated repository.</p>
 * @public
 */
export declare class LayerAlreadyExistsException extends __BaseException {
    readonly name: "LayerAlreadyExistsException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<LayerAlreadyExistsException, __BaseException>);
}
/**
 * <p>Layer parts must be at least 5 MiB in size.</p>
 * @public
 */
export declare class LayerPartTooSmallException extends __BaseException {
    readonly name: "LayerPartTooSmallException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<LayerPartTooSmallException, __BaseException>);
}
/**
 * <p>The upload could not be found, or the specified upload ID is not valid for this
 *             repository.</p>
 * @public
 */
export declare class UploadNotFoundException extends __BaseException {
    readonly name: "UploadNotFoundException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<UploadNotFoundException, __BaseException>);
}
/**
 * <p>A pull through cache rule with these settings already exists for the private
 *             registry.</p>
 * @public
 */
export declare class PullThroughCacheRuleAlreadyExistsException extends __BaseException {
    readonly name: "PullThroughCacheRuleAlreadyExistsException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<PullThroughCacheRuleAlreadyExistsException, __BaseException>);
}
/**
 * <p>The ARN of the secret specified in the pull through cache rule was not found. Update
 *             the pull through cache rule with a valid secret ARN and try again.</p>
 * @public
 */
export declare class SecretNotFoundException extends __BaseException {
    readonly name: "SecretNotFoundException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<SecretNotFoundException, __BaseException>);
}
/**
 * <p>The secret is unable to be accessed. Verify the resource permissions for the secret
 *             and try again.</p>
 * @public
 */
export declare class UnableToAccessSecretException extends __BaseException {
    readonly name: "UnableToAccessSecretException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<UnableToAccessSecretException, __BaseException>);
}
/**
 * <p>The secret is accessible but is unable to be decrypted. Verify the resource
 *             permisisons and try again.</p>
 * @public
 */
export declare class UnableToDecryptSecretValueException extends __BaseException {
    readonly name: "UnableToDecryptSecretValueException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<UnableToDecryptSecretValueException, __BaseException>);
}
/**
 * <p>The specified upstream registry isn't supported.</p>
 * @public
 */
export declare class UnsupportedUpstreamRegistryException extends __BaseException {
    readonly name: "UnsupportedUpstreamRegistryException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<UnsupportedUpstreamRegistryException, __BaseException>);
}
/**
 * <p>An invalid parameter has been specified. Tag keys can have a maximum character length of 128 characters, and tag values can have
 *             a maximum length of 256 characters.</p>
 * @public
 */
export declare class InvalidTagParameterException extends __BaseException {
    readonly name: "InvalidTagParameterException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidTagParameterException, __BaseException>);
}
/**
 * <p>The specified repository already exists in the specified registry.</p>
 * @public
 */
export declare class RepositoryAlreadyExistsException extends __BaseException {
    readonly name: "RepositoryAlreadyExistsException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<RepositoryAlreadyExistsException, __BaseException>);
}
/**
 * <p>The list of tags on the repository is over the limit. The maximum number of tags that
 *             can be applied to a repository is 50.</p>
 * @public
 */
export declare class TooManyTagsException extends __BaseException {
    readonly name: "TooManyTagsException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<TooManyTagsException, __BaseException>);
}
/**
 * <p>The repository creation template already exists. Specify a unique prefix and try
 *             again.</p>
 * @public
 */
export declare class TemplateAlreadyExistsException extends __BaseException {
    readonly name: "TemplateAlreadyExistsException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<TemplateAlreadyExistsException, __BaseException>);
}
/**
 * <p>The lifecycle policy could not be found, and no policy is set to the
 *             repository.</p>
 * @public
 */
export declare class LifecyclePolicyNotFoundException extends __BaseException {
    readonly name: "LifecyclePolicyNotFoundException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<LifecyclePolicyNotFoundException, __BaseException>);
}
/**
 * <p>The pull through cache rule was not found. Specify a valid pull through cache rule and
 *             try again.</p>
 * @public
 */
export declare class PullThroughCacheRuleNotFoundException extends __BaseException {
    readonly name: "PullThroughCacheRuleNotFoundException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<PullThroughCacheRuleNotFoundException, __BaseException>);
}
/**
 * <p>The registry doesn't have an associated registry policy.</p>
 * @public
 */
export declare class RegistryPolicyNotFoundException extends __BaseException {
    readonly name: "RegistryPolicyNotFoundException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<RegistryPolicyNotFoundException, __BaseException>);
}
/**
 * <p>The specified repository contains images. To delete a repository that contains images,
 *             you must force the deletion with the <code>force</code> parameter.</p>
 * @public
 */
export declare class RepositoryNotEmptyException extends __BaseException {
    readonly name: "RepositoryNotEmptyException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<RepositoryNotEmptyException, __BaseException>);
}
/**
 * <p>The specified repository creation template can't be found. Verify the registry ID and
 *             prefix and try again.</p>
 * @public
 */
export declare class TemplateNotFoundException extends __BaseException {
    readonly name: "TemplateNotFoundException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<TemplateNotFoundException, __BaseException>);
}
/**
 * <p>The specified repository and registry combination does not have an associated
 *             repository policy.</p>
 * @public
 */
export declare class RepositoryPolicyNotFoundException extends __BaseException {
    readonly name: "RepositoryPolicyNotFoundException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<RepositoryPolicyNotFoundException, __BaseException>);
}
/**
 * <p>The specified signing configuration was not found. This occurs when
 *             attempting to retrieve or delete a signing configuration that does not exist.</p>
 * @public
 */
export declare class SigningConfigurationNotFoundException extends __BaseException {
    readonly name: "SigningConfigurationNotFoundException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<SigningConfigurationNotFoundException, __BaseException>);
}
/**
 * <p>The specified pull time update exclusion was not found.</p>
 * @public
 */
export declare class ExclusionNotFoundException extends __BaseException {
    readonly name: "ExclusionNotFoundException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ExclusionNotFoundException, __BaseException>);
}
/**
 * <p>The image requested does not exist in the specified repository.</p>
 * @public
 */
export declare class ImageNotFoundException extends __BaseException {
    readonly name: "ImageNotFoundException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ImageNotFoundException, __BaseException>);
}
/**
 * <p>The specified image scan could not be found. Ensure that image scanning is enabled on
 *             the repository and try again.</p>
 * @public
 */
export declare class ScanNotFoundException extends __BaseException {
    readonly name: "ScanNotFoundException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ScanNotFoundException, __BaseException>);
}
/**
 * <p>The specified layer is not available because it is not associated with an image.
 *             Unassociated image layers may be cleaned up at any time.</p>
 * @public
 */
export declare class LayerInaccessibleException extends __BaseException {
    readonly name: "LayerInaccessibleException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<LayerInaccessibleException, __BaseException>);
}
/**
 * <p>The specified layers could not be found, or the specified layer is not valid for this
 *             repository.</p>
 * @public
 */
export declare class LayersNotFoundException extends __BaseException {
    readonly name: "LayersNotFoundException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<LayersNotFoundException, __BaseException>);
}
/**
 * <p>There was an issue getting the upstream layer matching the pull through cache
 *             rule.</p>
 * @public
 */
export declare class UnableToGetUpstreamLayerException extends __BaseException {
    readonly name: "UnableToGetUpstreamLayerException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<UnableToGetUpstreamLayerException, __BaseException>);
}
/**
 * <p>There is no dry run for this repository.</p>
 * @public
 */
export declare class LifecyclePolicyPreviewNotFoundException extends __BaseException {
    readonly name: "LifecyclePolicyPreviewNotFoundException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<LifecyclePolicyPreviewNotFoundException, __BaseException>);
}
/**
 * <p>The specified image has already been pushed, and there were no changes to the manifest
 *             or image tag after the last push.</p>
 * @public
 */
export declare class ImageAlreadyExistsException extends __BaseException {
    readonly name: "ImageAlreadyExistsException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ImageAlreadyExistsException, __BaseException>);
}
/**
 * <p>The specified image digest does not match the digest that Amazon ECR calculated for the
 *             image.</p>
 * @public
 */
export declare class ImageDigestDoesNotMatchException extends __BaseException {
    readonly name: "ImageDigestDoesNotMatchException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ImageDigestDoesNotMatchException, __BaseException>);
}
/**
 * <p>The specified image is tagged with a tag that already exists. The repository is
 *             configured for tag immutability.</p>
 * @public
 */
export declare class ImageTagAlreadyExistsException extends __BaseException {
    readonly name: "ImageTagAlreadyExistsException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ImageTagAlreadyExistsException, __BaseException>);
}
/**
 * <p>The manifest list is referencing an image that does not exist.</p>
 * @public
 */
export declare class ReferencedImagesNotFoundException extends __BaseException {
    readonly name: "ReferencedImagesNotFoundException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ReferencedImagesNotFoundException, __BaseException>);
}
/**
 * <p>The operation did not succeed because the account is managed by a organization policy.</p>
 * @public
 */
export declare class BlockedByOrganizationPolicyException extends __BaseException {
    readonly name: "BlockedByOrganizationPolicyException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<BlockedByOrganizationPolicyException, __BaseException>);
}
/**
 * <p>The specified pull time update exclusion already exists for the registry.</p>
 * @public
 */
export declare class ExclusionAlreadyExistsException extends __BaseException {
    readonly name: "ExclusionAlreadyExistsException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ExclusionAlreadyExistsException, __BaseException>);
}
/**
 * <p>The specified image is archived and cannot be scanned.</p>
 * @public
 */
export declare class ImageArchivedException extends __BaseException {
    readonly name: "ImageArchivedException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ImageArchivedException, __BaseException>);
}
/**
 * <p>The image is of a type that cannot be scanned.</p>
 * @public
 */
export declare class UnsupportedImageTypeException extends __BaseException {
    readonly name: "UnsupportedImageTypeException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<UnsupportedImageTypeException, __BaseException>);
}
/**
 * <p>The previous lifecycle policy preview request has not completed. Wait and try
 *             again.</p>
 * @public
 */
export declare class LifecyclePolicyPreviewInProgressException extends __BaseException {
    readonly name: "LifecyclePolicyPreviewInProgressException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<LifecyclePolicyPreviewInProgressException, __BaseException>);
}
/**
 * <p>The requested image storage class update is not supported.</p>
 * @public
 */
export declare class ImageStorageClassUpdateNotSupportedException extends __BaseException {
    readonly name: "ImageStorageClassUpdateNotSupportedException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ImageStorageClassUpdateNotSupportedException, __BaseException>);
}
/**
 * <p>The layer part size is not valid, or the first byte specified is not consecutive to
 *             the last byte of a previous layer part upload.</p>
 * @public
 */
export declare class InvalidLayerPartException extends __BaseException {
    readonly name: "InvalidLayerPartException";
    readonly $fault: "client";
    /**
     * <p>The registry ID associated with the exception.</p>
     * @public
     */
    registryId?: string | undefined;
    /**
     * <p>The repository name associated with the exception.</p>
     * @public
     */
    repositoryName?: string | undefined;
    /**
     * <p>The upload ID associated with the exception.</p>
     * @public
     */
    uploadId?: string | undefined;
    /**
     * <p>The last valid byte received from the layer part upload that is associated with the
     *             exception.</p>
     * @public
     */
    lastValidByteReceived?: number | undefined;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidLayerPartException, __BaseException>);
}
