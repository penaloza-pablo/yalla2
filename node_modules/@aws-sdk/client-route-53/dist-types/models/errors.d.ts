import type { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { Route53ServiceException as __BaseException } from "./Route53ServiceException";
/**
 * <p>Another user submitted a request to create, update, or delete the object at the same
 * 			time that you did. Retry the request. </p>
 * @public
 */
export declare class ConcurrentModification extends __BaseException {
    readonly name: "ConcurrentModification";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ConcurrentModification, __BaseException>);
}
/**
 * <p>The input is not valid.</p>
 * @public
 */
export declare class InvalidInput extends __BaseException {
    readonly name: "InvalidInput";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidInput, __BaseException>);
}
/**
 * <p>The key-signing key (KSK) status isn't valid or another KSK has the status
 * 				<code>INTERNAL_FAILURE</code>.</p>
 * @public
 */
export declare class InvalidKeySigningKeyStatus extends __BaseException {
    readonly name: "InvalidKeySigningKeyStatus";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidKeySigningKeyStatus, __BaseException>);
}
/**
 * <p>The KeyManagementServiceArn that you specified isn't valid to use with DNSSEC
 * 			signing.</p>
 * @public
 */
export declare class InvalidKMSArn extends __BaseException {
    readonly name: "InvalidKMSArn";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidKMSArn, __BaseException>);
}
/**
 * <p>Your hosted zone status isn't valid for this operation. In the hosted zone, change the
 * 			status to enable <code>DNSSEC</code> or disable <code>DNSSEC</code>.</p>
 * @public
 */
export declare class InvalidSigningStatus extends __BaseException {
    readonly name: "InvalidSigningStatus";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidSigningStatus, __BaseException>);
}
/**
 * <p>The specified key-signing key (KSK) doesn't exist.</p>
 * @public
 */
export declare class NoSuchKeySigningKey extends __BaseException {
    readonly name: "NoSuchKeySigningKey";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<NoSuchKeySigningKey, __BaseException>);
}
/**
 * <p>The cause of this error depends on the operation that you're performing:</p>
 *          <ul>
 *             <li>
 *                <p>
 *                   <b>Create a public hosted zone:</b> Two hosted zones
 * 					that have the same name or that have a parent/child relationship (example.com
 * 					and test.example.com) can't have any common name servers. You tried to create a
 * 					hosted zone that has the same name as an existing hosted zone or that's the
 * 					parent or child of an existing hosted zone, and you specified a delegation set
 * 					that shares one or more name servers with the existing hosted zone. For more
 * 					information, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateReusableDelegationSet.html">CreateReusableDelegationSet</a>.</p>
 *             </li>
 *             <li>
 *                <p>
 *                   <b>Create a private hosted zone:</b> A hosted zone
 * 					with the specified name already exists and is already associated with the Amazon
 * 					VPC that you specified.</p>
 *             </li>
 *             <li>
 *                <p>
 *                   <b>Associate VPCs with a private hosted zone:</b>
 * 					The VPC that you specified is already associated with another hosted zone that
 * 					has the same name.</p>
 *             </li>
 *          </ul>
 * @public
 */
export declare class ConflictingDomainExists extends __BaseException {
    readonly name: "ConflictingDomainExists";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ConflictingDomainExists, __BaseException>);
}
/**
 * <p>The VPC ID that you specified either isn't a valid ID or the current account is not
 * 			authorized to access this VPC.</p>
 * @public
 */
export declare class InvalidVPCId extends __BaseException {
    readonly name: "InvalidVPCId";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidVPCId, __BaseException>);
}
/**
 * <p>This operation can't be completed because the current account has reached the
 * 			limit on the resource you are trying to create. To request a higher limit, <a href="http://aws.amazon.com/route53-request">create a case</a> with the Amazon Web Services Support
 * 			Center.</p>
 * @public
 */
export declare class LimitsExceeded extends __BaseException {
    readonly name: "LimitsExceeded";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<LimitsExceeded, __BaseException>);
}
/**
 * <p>No hosted zone exists with the ID that you specified.</p>
 * @public
 */
export declare class NoSuchHostedZone extends __BaseException {
    readonly name: "NoSuchHostedZone";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<NoSuchHostedZone, __BaseException>);
}
/**
 * <p>Associating the specified VPC with the specified hosted zone has not been
 * 			authorized.</p>
 * @public
 */
export declare class NotAuthorizedException extends __BaseException {
    readonly name: "NotAuthorizedException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<NotAuthorizedException, __BaseException>);
}
/**
 * <p>If Amazon Route 53 can't process a request before the next request arrives, it will
 * 			reject subsequent requests for the same hosted zone and return an <code>HTTP 400
 * 				error</code> (<code>Bad request</code>). If Route 53 returns this error repeatedly
 * 			for the same request, we recommend that you wait, in intervals of increasing duration,
 * 			before you try the request again.</p>
 * @public
 */
export declare class PriorRequestNotComplete extends __BaseException {
    readonly name: "PriorRequestNotComplete";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<PriorRequestNotComplete, __BaseException>);
}
/**
 * <p>You're trying to associate a VPC with a public hosted zone. Amazon Route 53 doesn't
 * 			support associating a VPC with a public hosted zone.</p>
 * @public
 */
export declare class PublicZoneVPCAssociation extends __BaseException {
    readonly name: "PublicZoneVPCAssociation";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<PublicZoneVPCAssociation, __BaseException>);
}
/**
 * <p>This CIDR block is already in use.</p>
 * @public
 */
export declare class CidrBlockInUseException extends __BaseException {
    readonly name: "CidrBlockInUseException";
    readonly $fault: "client";
    Message?: string | undefined;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<CidrBlockInUseException, __BaseException>);
}
/**
 * <p>The CIDR collection version you provided, doesn't match the one in the
 * 				<code>ListCidrCollections</code> operation.</p>
 * @public
 */
export declare class CidrCollectionVersionMismatchException extends __BaseException {
    readonly name: "CidrCollectionVersionMismatchException";
    readonly $fault: "client";
    Message?: string | undefined;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<CidrCollectionVersionMismatchException, __BaseException>);
}
/**
 * <p>The CIDR collection you specified, doesn't exist.</p>
 * @public
 */
export declare class NoSuchCidrCollectionException extends __BaseException {
    readonly name: "NoSuchCidrCollectionException";
    readonly $fault: "client";
    Message?: string | undefined;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<NoSuchCidrCollectionException, __BaseException>);
}
/**
 * <p>This exception contains a list of messages that might contain one or more error
 * 			messages. Each error message indicates one error in the change batch.</p>
 * @public
 */
export declare class InvalidChangeBatch extends __BaseException {
    readonly name: "InvalidChangeBatch";
    readonly $fault: "client";
    /**
     * <p></p>
     * @public
     */
    messages?: string[] | undefined;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidChangeBatch, __BaseException>);
}
/**
 * <p>No health check exists with the specified ID.</p>
 * @public
 */
export declare class NoSuchHealthCheck extends __BaseException {
    readonly name: "NoSuchHealthCheck";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<NoSuchHealthCheck, __BaseException>);
}
/**
 * <p>The limit on the number of requests per second was exceeded.</p>
 * @public
 */
export declare class ThrottlingException extends __BaseException {
    readonly name: "ThrottlingException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ThrottlingException, __BaseException>);
}
/**
 * <p>A CIDR collection with this name and a different caller reference already exists in this account.</p>
 * @public
 */
export declare class CidrCollectionAlreadyExistsException extends __BaseException {
    readonly name: "CidrCollectionAlreadyExistsException";
    readonly $fault: "client";
    Message?: string | undefined;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<CidrCollectionAlreadyExistsException, __BaseException>);
}
/**
 * <p> The health check you're attempting to create already exists. Amazon Route 53 returns
 * 			this error when you submit a request that has the following values:</p>
 *          <ul>
 *             <li>
 *                <p>The same value for <code>CallerReference</code> as an existing health check,
 * 					and one or more values that differ from the existing health check that has the
 * 					same caller reference.</p>
 *             </li>
 *             <li>
 *                <p>The same value for <code>CallerReference</code> as a health check that you
 * 					created and later deleted, regardless of the other settings in the
 * 					request.</p>
 *             </li>
 *          </ul>
 * @public
 */
export declare class HealthCheckAlreadyExists extends __BaseException {
    readonly name: "HealthCheckAlreadyExists";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<HealthCheckAlreadyExists, __BaseException>);
}
/**
 * <p>This health check can't be created because the current account has reached the limit
 * 			on the number of active health checks.</p>
 *          <p>For information about default limits, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits</a> in the
 * 				<i>Amazon Route 53 Developer Guide</i>.</p>
 *          <p>For information about how to get the current limit for an account, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetAccountLimit.html">GetAccountLimit</a>. To request a higher limit, <a href="http://aws.amazon.com/route53-request">create a case</a> with the Amazon Web Services Support
 * 			Center.</p>
 *          <p>You have reached the maximum number of active health checks for an Amazon Web Services account. To request a higher limit, <a href="http://aws.amazon.com/route53-request">create a case</a> with the Amazon Web Services Support
 * 			Center.</p>
 * @public
 */
export declare class TooManyHealthChecks extends __BaseException {
    readonly name: "TooManyHealthChecks";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<TooManyHealthChecks, __BaseException>);
}
/**
 * <p>You can create a hosted zone that has the same name as an existing hosted zone
 * 			(example.com is common), but there is a limit to the number of hosted zones that have
 * 			the same name. If you get this error, Amazon Route 53 has reached that limit. If you own
 * 			the domain name and Route 53 generates this error, contact Customer Support.</p>
 * @public
 */
export declare class DelegationSetNotAvailable extends __BaseException {
    readonly name: "DelegationSetNotAvailable";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<DelegationSetNotAvailable, __BaseException>);
}
/**
 * <p>A reusable delegation set with the specified ID does not exist.</p>
 * @public
 */
export declare class DelegationSetNotReusable extends __BaseException {
    readonly name: "DelegationSetNotReusable";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<DelegationSetNotReusable, __BaseException>);
}
/**
 * <p>The hosted zone you're trying to create already exists. Amazon Route 53 returns this
 * 			error when a hosted zone has already been created with the specified
 * 				<code>CallerReference</code>.</p>
 * @public
 */
export declare class HostedZoneAlreadyExists extends __BaseException {
    readonly name: "HostedZoneAlreadyExists";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<HostedZoneAlreadyExists, __BaseException>);
}
/**
 * <p>The specified domain name is not valid.</p>
 * @public
 */
export declare class InvalidDomainName extends __BaseException {
    readonly name: "InvalidDomainName";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidDomainName, __BaseException>);
}
/**
 * <p>A reusable delegation set with the specified ID does not exist.</p>
 * @public
 */
export declare class NoSuchDelegationSet extends __BaseException {
    readonly name: "NoSuchDelegationSet";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<NoSuchDelegationSet, __BaseException>);
}
/**
 * <p>This operation can't be completed either because the current account has reached the
 * 			limit on the number of hosted zones or because you've reached the limit on the number of
 * 			hosted zones that can be associated with a reusable delegation set.</p>
 *          <p>For information about default limits, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits</a> in the
 * 				<i>Amazon Route 53 Developer Guide</i>.</p>
 *          <p>To get the current limit on hosted zones that can be created by an account, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetAccountLimit.html">GetAccountLimit</a>.</p>
 *          <p>To get the current limit on hosted zones that can be associated with a reusable
 * 			delegation set, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetReusableDelegationSetLimit.html">GetReusableDelegationSetLimit</a>.</p>
 *          <p>To request a higher limit, <a href="http://aws.amazon.com/route53-request">create a
 * 				case</a> with the Amazon Web Services Support Center.</p>
 * @public
 */
export declare class TooManyHostedZones extends __BaseException {
    readonly name: "TooManyHostedZones";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<TooManyHostedZones, __BaseException>);
}
/**
 * <p>Parameter name is not valid.</p>
 * @public
 */
export declare class InvalidArgument extends __BaseException {
    readonly name: "InvalidArgument";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidArgument, __BaseException>);
}
/**
 * <p>The key-signing key (KSK) name that you specified isn't a valid name.</p>
 * @public
 */
export declare class InvalidKeySigningKeyName extends __BaseException {
    readonly name: "InvalidKeySigningKeyName";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidKeySigningKeyName, __BaseException>);
}
/**
 * <p>You've already created a key-signing key (KSK) with this name or with the same customer managed key ARN.</p>
 * @public
 */
export declare class KeySigningKeyAlreadyExists extends __BaseException {
    readonly name: "KeySigningKeyAlreadyExists";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<KeySigningKeyAlreadyExists, __BaseException>);
}
/**
 * <p>You've reached the limit for the number of key-signing keys (KSKs). Remove at least
 * 			one KSK, and then try again.</p>
 * @public
 */
export declare class TooManyKeySigningKeys extends __BaseException {
    readonly name: "TooManyKeySigningKeys";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<TooManyKeySigningKeys, __BaseException>);
}
/**
 * <p>Amazon Route 53 doesn't have the permissions required to create log streams and send
 * 			query logs to log streams. Possible causes include the following:</p>
 *          <ul>
 *             <li>
 *                <p>There is no resource policy that specifies the log group ARN in the value for
 * 						<code>Resource</code>.</p>
 *             </li>
 *             <li>
 *                <p>The resource policy that includes the log group ARN in the value for
 * 						<code>Resource</code> doesn't have the necessary permissions.</p>
 *             </li>
 *             <li>
 *                <p>The resource policy hasn't finished propagating yet.</p>
 *             </li>
 *             <li>
 *                <p>The Key management service (KMS) key you specified doesn’t exist or it can’t
 * 					be used with the log group associated with query log. Update or provide a
 * 					resource policy to grant permissions for the KMS key.</p>
 *             </li>
 *             <li>
 *                <p>The Key management service (KMS) key you specified is marked as
 * 				disabled for the log group associated with query log. Update or provide
 * 				a resource policy to grant permissions for the KMS key.</p>
 *             </li>
 *          </ul>
 * @public
 */
export declare class InsufficientCloudWatchLogsResourcePolicy extends __BaseException {
    readonly name: "InsufficientCloudWatchLogsResourcePolicy";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InsufficientCloudWatchLogsResourcePolicy, __BaseException>);
}
/**
 * <p>There is no CloudWatch Logs log group with the specified ARN.</p>
 * @public
 */
export declare class NoSuchCloudWatchLogsLogGroup extends __BaseException {
    readonly name: "NoSuchCloudWatchLogsLogGroup";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<NoSuchCloudWatchLogsLogGroup, __BaseException>);
}
/**
 * <p>You can create only one query logging configuration for a hosted zone, and a query
 * 			logging configuration already exists for this hosted zone.</p>
 * @public
 */
export declare class QueryLoggingConfigAlreadyExists extends __BaseException {
    readonly name: "QueryLoggingConfigAlreadyExists";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<QueryLoggingConfigAlreadyExists, __BaseException>);
}
/**
 * <p>A delegation set with the same owner and caller reference combination has already been
 * 			created.</p>
 * @public
 */
export declare class DelegationSetAlreadyCreated extends __BaseException {
    readonly name: "DelegationSetAlreadyCreated";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<DelegationSetAlreadyCreated, __BaseException>);
}
/**
 * <p>The specified delegation set has already been marked as reusable.</p>
 * @public
 */
export declare class DelegationSetAlreadyReusable extends __BaseException {
    readonly name: "DelegationSetAlreadyReusable";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<DelegationSetAlreadyReusable, __BaseException>);
}
/**
 * <p>The specified HostedZone can't be found.</p>
 * @public
 */
export declare class HostedZoneNotFound extends __BaseException {
    readonly name: "HostedZoneNotFound";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<HostedZoneNotFound, __BaseException>);
}
/**
 * <p>The format of the traffic policy document that you specified in the
 * 				<code>Document</code> element is not valid.</p>
 * @public
 */
export declare class InvalidTrafficPolicyDocument extends __BaseException {
    readonly name: "InvalidTrafficPolicyDocument";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidTrafficPolicyDocument, __BaseException>);
}
/**
 * <p>This traffic policy can't be created because the current account has reached the limit
 * 			on the number of traffic policies.</p>
 *          <p>For information about default limits, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits</a> in the
 * 				<i>Amazon Route 53 Developer Guide</i>.</p>
 *          <p>To get the current limit for an account, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetAccountLimit.html">GetAccountLimit</a>. </p>
 *          <p>To request a higher limit, <a href="http://aws.amazon.com/route53-request">create a
 * 				case</a> with the Amazon Web Services Support Center.</p>
 * @public
 */
export declare class TooManyTrafficPolicies extends __BaseException {
    readonly name: "TooManyTrafficPolicies";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<TooManyTrafficPolicies, __BaseException>);
}
/**
 * <p>A traffic policy that has the same value for <code>Name</code> already exists.</p>
 * @public
 */
export declare class TrafficPolicyAlreadyExists extends __BaseException {
    readonly name: "TrafficPolicyAlreadyExists";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<TrafficPolicyAlreadyExists, __BaseException>);
}
/**
 * <p>No traffic policy exists with the specified ID.</p>
 * @public
 */
export declare class NoSuchTrafficPolicy extends __BaseException {
    readonly name: "NoSuchTrafficPolicy";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<NoSuchTrafficPolicy, __BaseException>);
}
/**
 * <p>This traffic policy instance can't be created because the current account has reached
 * 			the limit on the number of traffic policy instances.</p>
 *          <p>For information about default limits, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/DNSLimitations.html">Limits</a> in the
 * 				<i>Amazon Route 53 Developer Guide</i>.</p>
 *          <p>For information about how to get the current limit for an account, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetAccountLimit.html">GetAccountLimit</a>.</p>
 *          <p>To request a higher limit, <a href="http://aws.amazon.com/route53-request">create a
 * 				case</a> with the Amazon Web Services Support Center.</p>
 * @public
 */
export declare class TooManyTrafficPolicyInstances extends __BaseException {
    readonly name: "TooManyTrafficPolicyInstances";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<TooManyTrafficPolicyInstances, __BaseException>);
}
/**
 * <p>There is already a traffic policy instance with the specified ID.</p>
 * @public
 */
export declare class TrafficPolicyInstanceAlreadyExists extends __BaseException {
    readonly name: "TrafficPolicyInstanceAlreadyExists";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<TrafficPolicyInstanceAlreadyExists, __BaseException>);
}
/**
 * <p>This traffic policy version can't be created because you've reached the limit of 1000
 * 			on the number of versions that you can create for the current traffic policy.</p>
 *          <p>To create more traffic policy versions, you can use <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GetTrafficPolicy.html">GetTrafficPolicy</a>
 * 			to get the traffic policy document for a specified traffic policy version, and then use
 * 				<a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateTrafficPolicy.html">CreateTrafficPolicy</a> to create a new traffic policy using the traffic policy
 * 			document.</p>
 * @public
 */
export declare class TooManyTrafficPolicyVersionsForCurrentPolicy extends __BaseException {
    readonly name: "TooManyTrafficPolicyVersionsForCurrentPolicy";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<TooManyTrafficPolicyVersionsForCurrentPolicy, __BaseException>);
}
/**
 * <p>You've created the maximum number of authorizations that can be created for the
 * 			specified hosted zone. To authorize another VPC to be associated with the hosted zone,
 * 			submit a <code>DeleteVPCAssociationAuthorization</code> request to remove an existing
 * 			authorization. To get a list of existing authorizations, submit a
 * 				<code>ListVPCAssociationAuthorizations</code> request.</p>
 * @public
 */
export declare class TooManyVPCAssociationAuthorizations extends __BaseException {
    readonly name: "TooManyVPCAssociationAuthorizations";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<TooManyVPCAssociationAuthorizations, __BaseException>);
}
/**
 * <p>The key-signing key (KSK) is specified in a parent DS record.</p>
 * @public
 */
export declare class KeySigningKeyInParentDSRecord extends __BaseException {
    readonly name: "KeySigningKeyInParentDSRecord";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<KeySigningKeyInParentDSRecord, __BaseException>);
}
/**
 * <p>The key-signing key (KSK) that you specified can't be deactivated because it's the
 * 			only KSK for a currently-enabled DNSSEC. Disable DNSSEC signing, or add or enable
 * 			another KSK.</p>
 * @public
 */
export declare class KeySigningKeyInUse extends __BaseException {
    readonly name: "KeySigningKeyInUse";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<KeySigningKeyInUse, __BaseException>);
}
/**
 * <p>This CIDR collection is in use, and isn't empty.</p>
 * @public
 */
export declare class CidrCollectionInUseException extends __BaseException {
    readonly name: "CidrCollectionInUseException";
    readonly $fault: "client";
    Message?: string | undefined;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<CidrCollectionInUseException, __BaseException>);
}
/**
 * <p>This error code is not in use.</p>
 *
 * @deprecated deprecated
 * @public
 */
export declare class HealthCheckInUse extends __BaseException {
    readonly name: "HealthCheckInUse";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<HealthCheckInUse, __BaseException>);
}
/**
 * <p>The hosted zone contains resource records that are not SOA or NS records.</p>
 * @public
 */
export declare class HostedZoneNotEmpty extends __BaseException {
    readonly name: "HostedZoneNotEmpty";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<HostedZoneNotEmpty, __BaseException>);
}
/**
 * <p>There is no DNS query logging configuration with the specified ID.</p>
 * @public
 */
export declare class NoSuchQueryLoggingConfig extends __BaseException {
    readonly name: "NoSuchQueryLoggingConfig";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<NoSuchQueryLoggingConfig, __BaseException>);
}
/**
 * <p>The specified delegation contains associated hosted zones which must be deleted before
 * 			the reusable delegation set can be deleted.</p>
 * @public
 */
export declare class DelegationSetInUse extends __BaseException {
    readonly name: "DelegationSetInUse";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<DelegationSetInUse, __BaseException>);
}
/**
 * <p>One or more traffic policy instances were created by using the specified traffic
 * 			policy.</p>
 * @public
 */
export declare class TrafficPolicyInUse extends __BaseException {
    readonly name: "TrafficPolicyInUse";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<TrafficPolicyInUse, __BaseException>);
}
/**
 * <p>No traffic policy instance exists with the specified ID.</p>
 * @public
 */
export declare class NoSuchTrafficPolicyInstance extends __BaseException {
    readonly name: "NoSuchTrafficPolicyInstance";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<NoSuchTrafficPolicyInstance, __BaseException>);
}
/**
 * <p>The VPC that you specified is not authorized to be associated with the hosted
 * 			zone.</p>
 * @public
 */
export declare class VPCAssociationAuthorizationNotFound extends __BaseException {
    readonly name: "VPCAssociationAuthorizationNotFound";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<VPCAssociationAuthorizationNotFound, __BaseException>);
}
/**
 * <p>The hosted zone doesn't have any DNSSEC resources.</p>
 * @public
 */
export declare class DNSSECNotFound extends __BaseException {
    readonly name: "DNSSECNotFound";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<DNSSECNotFound, __BaseException>);
}
/**
 * <p>The VPC that you're trying to disassociate from the private hosted zone is the last
 * 			VPC that is associated with the hosted zone. Amazon Route 53 doesn't support
 * 			disassociating the last VPC from a hosted zone.</p>
 * @public
 */
export declare class LastVPCAssociation extends __BaseException {
    readonly name: "LastVPCAssociation";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<LastVPCAssociation, __BaseException>);
}
/**
 * <p>The specified VPC and hosted zone are not currently associated.</p>
 * @public
 */
export declare class VPCAssociationNotFound extends __BaseException {
    readonly name: "VPCAssociationNotFound";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<VPCAssociationNotFound, __BaseException>);
}
/**
 * <p>The hosted zone nameservers don't match the parent nameservers. The hosted zone and
 * 			parent must have the same nameservers.</p>
 * @public
 */
export declare class HostedZonePartiallyDelegated extends __BaseException {
    readonly name: "HostedZonePartiallyDelegated";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<HostedZonePartiallyDelegated, __BaseException>);
}
/**
 * <p>A key-signing key (KSK) with <code>ACTIVE</code> status wasn't found.</p>
 * @public
 */
export declare class KeySigningKeyWithActiveStatusNotFound extends __BaseException {
    readonly name: "KeySigningKeyWithActiveStatusNotFound";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<KeySigningKeyWithActiveStatusNotFound, __BaseException>);
}
/**
 * <p>A change with the specified change ID does not exist.</p>
 * @public
 */
export declare class NoSuchChange extends __BaseException {
    readonly name: "NoSuchChange";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<NoSuchChange, __BaseException>);
}
/**
 * <p>Amazon Route 53 doesn't support the specified geographic location. For a list of
 * 			supported geolocation codes, see the <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_GeoLocation.html">GeoLocation</a> data
 * 			type.</p>
 * @public
 */
export declare class NoSuchGeoLocation extends __BaseException {
    readonly name: "NoSuchGeoLocation";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<NoSuchGeoLocation, __BaseException>);
}
/**
 * <p>The resource you're trying to access is unsupported on this Amazon Route 53
 * 			endpoint.</p>
 * @public
 */
export declare class IncompatibleVersion extends __BaseException {
    readonly name: "IncompatibleVersion";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<IncompatibleVersion, __BaseException>);
}
/**
 * <p>The specified hosted zone is a public hosted zone, not a private hosted zone.</p>
 * @public
 */
export declare class HostedZoneNotPrivate extends __BaseException {
    readonly name: "HostedZoneNotPrivate";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<HostedZoneNotPrivate, __BaseException>);
}
/**
 * <p>The CIDR collection location doesn't match any locations in your account.</p>
 * @public
 */
export declare class NoSuchCidrLocationException extends __BaseException {
    readonly name: "NoSuchCidrLocationException";
    readonly $fault: "client";
    Message?: string | undefined;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<NoSuchCidrLocationException, __BaseException>);
}
/**
 * <p>The value that you specified to get the second or subsequent page of results is
 * 			invalid.</p>
 * @public
 */
export declare class InvalidPaginationToken extends __BaseException {
    readonly name: "InvalidPaginationToken";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidPaginationToken, __BaseException>);
}
/**
 * <p>The value of <code>HealthCheckVersion</code> in the request doesn't match the value of
 * 				<code>HealthCheckVersion</code> in the health check.</p>
 * @public
 */
export declare class HealthCheckVersionMismatch extends __BaseException {
    readonly name: "HealthCheckVersionMismatch";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<HealthCheckVersionMismatch, __BaseException>);
}
/**
 * <p>You tried to update a traffic policy instance by using a traffic policy version that
 * 			has a different DNS type than the current type for the instance. You specified the type
 * 			in the JSON document in the <code>CreateTrafficPolicy</code> or
 * 				<code>CreateTrafficPolicyVersion</code>request. </p>
 * @public
 */
export declare class ConflictingTypes extends __BaseException {
    readonly name: "ConflictingTypes";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ConflictingTypes, __BaseException>);
}
